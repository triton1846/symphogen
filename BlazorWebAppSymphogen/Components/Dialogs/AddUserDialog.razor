@using FluentValidation
@using System.Text.RegularExpressions

<MudDialog>
    <TitleContent>
        <MudText Typo="Typo.h6">@(IsEditMode ? "Edit" : "Add New") User</MudText>
    </TitleContent>
    <DialogContent>
        <MudForm @ref="_form" Model="User" Validation="_validator.ValidateValue" ValidationDelay="0">
            <MudGrid>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="User.FullName" For="@(() => User.FullName)" Label="Full Name" Immediate="true" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="User.Email" For="@(() => User.Email)" Label="Email" Immediate="true" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="User.Department" For="@(() => User.Department)" Label="Department" Immediate="true" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="User.Location" For="@(() => User.Location)" Label="Location" Immediate="true" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="User.JobTitle" For="@(() => User.JobTitle)" Label="Job Title" Immediate="true" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="User.OfficePhoneNumber" For="@(() => User.OfficePhoneNumber)" Label="Office Phone Number" Immediate="true" />
                </MudItem>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="User.Initials" For="@(() => User.Initials)" Label="Initials" Immediate="true" />
                </MudItem>
                <MudItem xs="12">
                    <MudSelect T="Models.Team"
                               Label="Teams"
                               MultiSelection="true"
                               Immediate="true"
                               SelectedValues="User.Teams"
                               SelectedValuesChanged="OnUserTeamsSelected"
                               ToStringFunc="@(team => team.Name)">
                        @foreach (var team in Teams.OrderBy(t => t.Name))
                        {
                            <MudSelectItem T="Models.Team" Value="@team">@team.Name</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>
        </MudForm>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        @if (IsEditMode)
        {
            <MudButton Color="Color.Error" Variant="Variant.Text" OnClick="() => MudDialog?.Close(DialogResult.Ok(true))">
                Delete
            </MudButton>
        }
        <MudButton Color="Color.Primary"
                   Variant="Variant.Filled"
                   OnClick="SubmitUser">
            Save
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance? MudDialog { get; set; }

    [Parameter]
    public List<Models.Team> Teams { get; set; } = [];

    [Parameter]
    public bool IsEditMode { get; set; } = false;

    [Parameter]
    public Models.User User { get; set; } = new Models.User
    {
        Id = Guid.NewGuid().ToString(),
        Teams = new List<Models.Team>(),
        TeamIds = new List<string>()
    };

    private MudForm? _form;
    private UserModelFluentValidator _validator = new UserModelFluentValidator();

    private void OnUserTeamsSelected(IEnumerable<Models.Team> selectedTeams)
    {
        User.Teams = selectedTeams.ToList();
        User.TeamIds = User.Teams.Select(t => t.Id).ToList();
    }

    private void Cancel() => MudDialog?.Cancel();
    private void Submit() => MudDialog?.Close(DialogResult.Ok(User));

    private async Task SubmitUser()
    {
        ArgumentNullException.ThrowIfNull(_form);

        await _form.Validate();
        if (!_form.IsValid)
        {
            return; // Form is invalid, do not submit
        }

        Submit();
    }

    public class UserModelFluentValidator : AbstractValidator<Models.User>
    {
        public UserModelFluentValidator()
        {
            RuleFor(user => user.FullName)
                .NotEmpty().WithMessage("'Full Name' must not be empty.")
                .Must(fullName =>
                    !string.IsNullOrWhiteSpace(fullName) &&
                    fullName.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length >= 2
                ).WithMessage("'Full Name' must contain at least a first and last name.");

            RuleFor(user => user.Email)
                .NotEmpty().WithMessage("'Full Name' must not be empty.")
                .EmailAddress().WithMessage("'Email' is not a valid email address.")
                .Must(email =>
                    !string.IsNullOrWhiteSpace(email) &&
                    Regex.IsMatch(email, @"^[^@\s]+@[^@\s]+\.[A-Za-z]{2,}$")
                ).WithMessage("'Email' is not a valid email address.");

            RuleFor(user => user.Department).NotEmpty().WithMessage("'Department' is required.");

            RuleFor(user => user.Location).NotEmpty().WithMessage("'Location' is required.");

            RuleFor(user => user.JobTitle).NotEmpty().WithMessage("'Job Title' is required.");

            RuleFor(user => user.OfficePhoneNumber)
                .Matches(@"^(?:(?:\+|00)?\d{1,3}[\s\-]?)?(?:\d{2,4}[\s\-]?){2,5}$")
                .When(user => !string.IsNullOrWhiteSpace(user.OfficePhoneNumber))
                .WithMessage("Invalid phone number format.");

            RuleFor(user => user.Initials)
                .NotEmpty()
                .WithMessage("'Initials' are required.");
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<Models.User>.CreateWithOptions((Models.User)model, x => x.IncludeProperties(propertyName)));
            if (result.IsValid)
                return Array.Empty<string>();
            return result.Errors.Select(e => e.ErrorMessage);
        };
    }
}
